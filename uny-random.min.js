// src/utils.js
var TAU = Math.fround(2 * Math.PI);
var MANTISSA_MAX = 2 ** 23 - 1;
var BOROSH_INIT = 1812433253;
var toUnsigned = (num) => num >>> 0;
var borosh13 = (num) => toUnsigned(Math.imul(BOROSH_INIT, num) + 1);
var lerp = (x, y, a) => x * (1 - a) + y * a;
var roundTo7 = (num) => Number(num.toPrecision(7));
var value = (rand) => Math.fround(toUnsigned(rand & MANTISSA_MAX) / MANTISSA_MAX);
var valueInv = (rand) => Math.fround(1 - value(rand));
var xorshift128 = ([x, , , y]) => {
  x ^= x << 11;
  x ^= x >>> 8;
  y ^= y >>> 19;
  return toUnsigned(y ^ x);
};
var generateStateFromSeed = (seed) => {
  const s0 = toUnsigned(seed);
  const s1 = borosh13(s0);
  const s2 = borosh13(s1);
  const s3 = borosh13(s2);
  return [s0, s1, s2, s3];
};
var rangeInt = (rand, min, max) => {
  const result = rand % (min - max) + min;
  if (min > max) {
    return 2 * min - result;
  }
  return result;
};
var rangeFloat = (rand, min, max) => {
  const roundedMin = Math.fround(min);
  const roundedMax = Math.fround(max);
  return Math.fround(value(rand) * (roundedMin - roundedMax) + roundedMax);
};
var polarCoordinatesToVector = ({ theta, radius }) => {
  const x = radius * Math.cos(theta);
  const y = radius * Math.sin(theta);
  return { x, y };
};
var sphericalCoordinatesToVector = ({ theta, phi, radius }) => {
  const sinTheta = Math.sin(theta);
  const cosTheta = Math.cos(theta);
  const sinPhi = Math.sin(phi);
  const cosPhi = Math.cos(phi);
  const x = radius * sinPhi * cosTheta;
  const y = radius * sinPhi * sinTheta;
  const z = radius * cosPhi;
  return { x, y, z };
};
var normalize3dVector = ({ x: baseX, y: baseY, z: baseZ }) => {
  const length = Math.sqrt(baseX ** 2 + baseY ** 2 + baseZ ** 2);
  const x = baseX / length;
  const y = baseY / length;
  const z = baseZ / length;
  return { x, y, z };
};
var normalizeQuaternion = ({ x: baseX, y: baseY, z: baseZ, w: baseW }) => {
  const length = Math.sqrt(baseW ** 2 + baseX ** 2 + baseY ** 2 + baseZ ** 2) * (baseW >= 0 || -1);
  const x = baseX / length;
  const y = baseY / length;
  const z = baseZ / length;
  const w = baseW / length;
  return { x, y, z, w };
};
var hopfMapping = ({ x: u1, y: u2, z: u3 }) => {
  const sqrtU1 = Math.sqrt(u1);
  const invSqrtU1 = Math.sqrt(1 - u1);
  const flipFactor = u3 <= 0.25 || u3 > 0.75 || -1;
  const x = sqrtU1 * Math.sin(TAU * u2) * -flipFactor;
  const y = sqrtU1 * Math.cos(TAU * u2) * flipFactor;
  const z = invSqrtU1 * Math.sin(TAU * u3) * -flipFactor;
  const w = invSqrtU1 * Math.cos(TAU * u3) * flipFactor;
  return { x, y, z, w };
};
var hsvToRgb = (h, s, v) => {
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  let r = 0;
  let g = 0;
  let b = 0;
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return { r, g, b };
};

// src/uny-random.js
var UnyRandom = class {
  #state;
  /** @param seed Default value = Date.now() */
  constructor(seed = Date.now()) {
    this.#state = generateStateFromSeed(seed);
  }
  /** Initializes the random number generator state with a seed
   * @see {@link https://docs.unity3d.com/ScriptReference/Random.InitState.html UnityEngine.Random.InitState}
   * @param seed Default value = Date.now()
   */
  initState(seed = Date.now()) {
    this.#state = generateStateFromSeed(seed);
    return this;
  }
  /** Gets or sets the internal Xorshift 128 state array of the random number generator
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-state.html UnityEngine.Random.state}
   * @return {[number,number,number,number]}
   */
  get state() {
    return this.#state;
  }
  set state(newState) {
    this.#state = newState;
  }
  /** Returns a random unsigned int within [0..MAX_UINT32] (range is inclusive)
   * @returns {number}
   * @readonly
   */
  get next() {
    const newRandom = xorshift128(this.#state);
    this.#state = [...this.#state.slice(1), newRandom];
    return newRandom;
  }
  /** Skips 'step' number of generated numbers.
   * @param {number} steps
   */
  skip(steps) {
    for (let i = 0; i < steps; ++i) {
      this.next;
    }
    return this;
  }
  /** Returns a random float within [0.0..1.0] (range is inclusive)
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-value.html UnityEngine.Random.value}
   * @readonly
   */
  get value() {
    return roundTo7(value(this.next));
  }
  /** Returns a random float within [min..max] (range is inclusive).  
   * Used to controll behaviour since JS auto-converts whole numbers to Integers
   * @see {@link https://docs.unity3d.com/ScriptReference/Random.Range.html UnityEngine.Random.Range}
   * @param {number} min
   * @param {number} max
   */
  rangeFloat(min, max) {
    return roundTo7(rangeFloat(this.next, min, max));
  }
  /** Returns a random int within [min..max) (range max is eclusive).  
   * Used to controll behaviour since JS auto-converts whole numbers to Integers
   * @see {@link https://docs.unity3d.com/ScriptReference/Random.Range.html UnityEngine.Random.Range}
   * @param {number} min
   * @param {number} max
   */
  rangeInt(min, max) {
    return rangeInt(this.next, min, max);
  }
  /** Returns a random number in a range.
   * Using {@link rangeInt rangeInt} if both parameters are integers,
   * else using {@link rangeFloat rangeFloat}.  
   * Minimum value is == 0 if called with only one parameter.
   * 
   * @see {@link https://docs.unity3d.com/ScriptReference/Random.Range.html UnityEngine.Random.Range}
   * @param {number} minOrMax Max value if called with one parameter, else minimum
   * @param {number} [max]
   */
  range(minOrMax, max) {
    return Number.isInteger(minOrMax) && (max === void 0 || Number.isInteger(max)) ? this.rangeInt(minOrMax, max) : this.rangeFloat(minOrMax, max);
  }
  /** Returns a random point inside or on a circle with radius 1.0
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-insideUnitCircle.html UnityEngine.Random.insideUnitCircle}
   * @readonly
   */
  get insideUnitCircle() {
    const polarCoordinates = {
      theta: valueInv(this.next) * TAU,
      radius: Math.sqrt(valueInv(this.next))
    };
    const { x, y } = polarCoordinatesToVector(polarCoordinates);
    return {
      x: roundTo7(x),
      y: roundTo7(y)
    };
  }
  /** Returns a random point inside or on a sphere with radius 1.0
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-insideUnitSphere.html UnityEngine.Random.insideUnitSphere}
   * @readonly
   */
  get insideUnitSphere() {
    const sphericalCoordinates = {
      phi: Math.acos(2 * valueInv(this.next) - 1),
      theta: valueInv(this.next) * TAU,
      radius: value(this.next) ** (1 / 3)
    };
    const { x, y, z } = sphericalCoordinatesToVector(sphericalCoordinates);
    return {
      x: roundTo7(x),
      y: roundTo7(y),
      z: roundTo7(z)
    };
  }
  /** Returns a random point on the surface of a sphere with radius 1.0
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-onUnitSphere.html UnityEngine.Random.onUnitSphere}
   * @readonly
   */
  get onUnitSphere() {
    const { x, y, z } = normalize3dVector(this.insideUnitSphere);
    return {
      x: roundTo7(x),
      y: roundTo7(y),
      z: roundTo7(z)
    };
  }
  /** Returns a random rotation
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-rotation.html UnityEngine.Random.rotation}
   * @readonly
   */
  get rotation() {
    const baseQuaternion = {
      x: rangeFloat(this.next, -1, 1),
      y: rangeFloat(this.next, -1, 1),
      z: rangeFloat(this.next, -1, 1),
      w: rangeFloat(this.next, -1, 1)
    };
    const { x, y, z, w } = normalizeQuaternion(baseQuaternion);
    return {
      x: roundTo7(x),
      y: roundTo7(y),
      z: roundTo7(z),
      w: roundTo7(w)
    };
  }
  /** Returns a random rotation with uniform distribution
   * @see {@link https://docs.unity3d.com/ScriptReference/Random-rotationUniform.html UnityEngine.Random.rotationUniform}
   * @readonly
   */
  get rotationUniform() {
    const baseVector = {
      x: value(this.next),
      y: value(this.next),
      z: value(this.next)
    };
    const { x, y, z, w } = hopfMapping(baseVector);
    return {
      x: roundTo7(x),
      y: roundTo7(y),
      z: roundTo7(z),
      w: roundTo7(w)
    };
  }
  /** Generates a random color from HSV and alpha ranges.
   * @see {@link https://docs.unity3d.com/ScriptReference/Random.ColorHSV.html UnityEngine.Random.ColorHSV}
   */
  colorHSV(hueMin = 0, hueMax = 1, saturationMin = 0, saturationMax = 1, valueMin = 0, valueMax = 1, alphaMin = 1, alphaMax = 1) {
    const h = lerp(hueMin, hueMax, value(this.next));
    const s = lerp(saturationMin, saturationMax, value(this.next));
    const v = lerp(valueMin, valueMax, value(this.next));
    const a = lerp(alphaMin, alphaMax, value(this.next));
    const { r, g, b } = hsvToRgb(h, s, v);
    return {
      r: roundTo7(r),
      g: roundTo7(g),
      b: roundTo7(b),
      a: roundTo7(a)
    };
  }
};
var uny_random_default = new UnyRandom();
export {
  UnyRandom,
  uny_random_default as default
};
